name: Deploy Service

on:
  workflow_dispatch:
    inputs:
      service_name:
        description: 'Service name (folder name, e.g., payment-service)'
        required: true
        type: string
      ref:
        description: 'Git ref/branch to checkout (optional, defaults to current ref)'
        required: false
        type: string
        default: ''
      service_path:
        description: 'Optional: path to service folder (relative to repo root). If empty, defaults to service_name'
        required: false
        type: string
        default: ''
      skip_tests:
        description: 'Skip tests'
        required: false
        type: boolean
        default: false
      skip_validation:
        description: 'Skip service config validation'
        required: false
        type: boolean
        default: false
      auto_approve:
        description: 'Auto-approve deployment (use with caution)'
        required: false
        type: boolean
        default: false
  push:
    branches:
      - production
    paths:
      - '**/service.yml'
      - '**/Dockerfile'
      - '**/pom.xml'
      - '**/*.csproj'
      - '**/package.json'
      - '**/requirements.txt'

permissions:
  contents: read
  id-token: write
  pull-requests: write

jobs:
  discover-service:
    name: Discover Service
    runs-on: ubuntu-latest
    outputs:
      service_name: ${{ steps.discover.outputs.service_name }}
      service_path: ${{ steps.discover.outputs.service_path }}
      service_config: ${{ steps.discover.outputs.service_config }}
      changed_files: ${{ steps.discover.outputs.changed_files }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.inputs.ref != '' && github.event.inputs.ref || github.ref }}
      
      - name: Discover Service
        id: discover
        run: |
          set -euo pipefail
          
          BASE_SHA="${{ github.event.before }}"
          HEAD_SHA="${{ github.sha }}"
          CHANGED_FILES=""

          # Normalize BASE_SHA for cases where GitHub provides 000... or empty (e.g., force push / first commit)
          if [ -z "$BASE_SHA" ] || [ "$BASE_SHA" = "0000000000000000000000000000000000000000" ]; then
            BASE_SHA=$(git rev-parse HEAD^ 2>/dev/null || true)
          fi

          # Get service name/path from input or changed files
          SERVICE_PATH=""
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SERVICE_NAME="${{ github.event.inputs.service_name }}"
            SERVICE_PATH_INPUT="${{ github.event.inputs.service_path }}"
            if [ -n "$SERVICE_PATH_INPUT" ]; then
              SERVICE_PATH="$SERVICE_PATH_INPUT"
              echo "üìã Using service path from workflow_dispatch: $SERVICE_PATH"
            else
              SERVICE_PATH="$SERVICE_NAME"
              echo "üìã Using service name from workflow_dispatch: $SERVICE_NAME"
            fi
            # No diff when manual; set changed files to service config path for reference
            CHANGED_FILES="$SERVICE_PATH/service.yml"
          else
            # Auto-detect from changed files
            echo "üîç Auto-detecting service from changed files..."
            
            if [ -n "$BASE_SHA" ]; then
              CHANGED_FILES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" 2>/dev/null || echo "")
            else
              # Fallback to previous commit if BASE_SHA not available
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
            fi
            
            if [ -z "$CHANGED_FILES" ]; then
              echo "‚ùå No changed files detected"
              echo "üí° Tip: run via workflow_dispatch and provide service_name, or ensure there are changes in service paths."
              exit 1
            fi
            
            # Find service.yml in changed files
            SERVICE_NAME=$(echo "$CHANGED_FILES" | grep -oP '^\K[^/]+(?=/service\.yml)' | head -1)
            
            if [ -z "$SERVICE_NAME" ]; then
              # Try to find from Dockerfile or source files
              SERVICE_NAME=$(echo "$CHANGED_FILES" | grep -oP '^\K[^/]+(?=/)' | sort -u | head -1)
            fi

            # If still empty, fail
            if [ -z "$SERVICE_NAME" ]; then
              echo "‚ùå Could not determine service name from changes"
              echo "üí° Tip: run via workflow_dispatch and provide service_name/service_path."
              exit 1
            fi

            # Default service path equals service name when auto-detected
            SERVICE_PATH="$SERVICE_NAME"
          fi
          
          if [ -z "$SERVICE_NAME" ]; then
            echo "‚ùå Could not determine service name"
            echo "üí° Tip: Specify service_name in workflow_dispatch or ensure service.yml exists"
            exit 1
          fi
          
          SERVICE_CONFIG="$SERVICE_PATH/service.yml"
          
          if [ ! -f "$SERVICE_CONFIG" ]; then
            echo "‚ùå Service config not found: $SERVICE_CONFIG"
            echo "üìÇ Repo root contents:"
            ls -la
            echo "üìÇ Service path contents (if exists):"
            ls -la "$SERVICE_PATH" 2>/dev/null || true
            echo "üîç Searching for service.yml in repo:"
            find . -maxdepth 4 -name 'service.yml' -print || true
            echo "üí° Hints:"
            echo "  - ƒê·∫£m b·∫£o ƒë√£ commit & push service.yml l√™n branch/ref n√†y."
            echo "  - N·∫øu d√πng workflow_dispatch, set 'service_path' n·∫øu service n·∫±m trong th∆∞ m·ª•c con kh√°c."
            echo "  - Ho·∫∑c set 'ref' ƒë·ªÉ checkout ƒë√∫ng branch c√≥ service."
            echo "  - C√≥ th·ªÉ t·∫°o service b·∫±ng: ./scripts/create-service.sh $SERVICE_NAME"
            exit 1
          fi
          
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "service_path=$SERVICE_PATH" >> $GITHUB_OUTPUT
          echo "service_config=$SERVICE_CONFIG" >> $GITHUB_OUTPUT
          # Ensure CHANGED_FILES is defined
          : "${CHANGED_FILES:=}"

          # Write changed files safely (multiline) to output
          {
            echo "changed_files<<EOF"
            echo "$CHANGED_FILES"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          
          echo "‚úÖ Discovered service: $SERVICE_NAME"
          echo "üìÅ Path: $SERVICE_PATH"
          echo "üìù Config: $SERVICE_CONFIG"

  validate-service:
    name: Validate Service Config
    needs: discover-service
    runs-on: ubuntu-latest
    if: ${{ !github.event.inputs.skip_validation }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
      
      - name: Validate Service Config
        run: |
          SERVICE_CONFIG="${{ needs.discover-service.outputs.service_config }}"
          chmod +x scripts/validate-service-config.sh
          ./scripts/validate-service-config.sh "$SERVICE_CONFIG"
      
      - name: Check Dockerfile
        run: |
          SERVICE_PATH="${{ needs.discover-service.outputs.service_path }}"
          SERVICE_CONFIG="${{ needs.discover-service.outputs.service_config }}"
          
          # Get dockerfile path from config
          DOCKERFILE=$(yq eval '.service.build.dockerfile' "$SERVICE_CONFIG" || echo "Dockerfile")
          DOCKERFILE_PATH="$SERVICE_PATH/$DOCKERFILE"
          
          if [ ! -f "$DOCKERFILE_PATH" ]; then
            echo "‚ùå Dockerfile not found: $DOCKERFILE_PATH"
            exit 1
          fi
          
          echo "‚úÖ Dockerfile found: $DOCKERFILE_PATH"
          
          # Basic Dockerfile validation
          if ! grep -q "FROM" "$DOCKERFILE_PATH"; then
            echo "‚ùå Invalid Dockerfile: missing FROM instruction"
            exit 1
          fi
          
          echo "‚úÖ Dockerfile is valid"

  build-and-test:
    name: Build and Test
    needs: [discover-service, validate-service]
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.build.outputs.image }}
      language: ${{ steps.config.outputs.language }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Parse Service Config
        id: config
        run: |
          SERVICE_CONFIG="${{ needs.discover-service.outputs.service_config }}"
          
          # Install yq
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          # Extract config values
          LANGUAGE=$(yq eval '.service.build.language' "$SERVICE_CONFIG" || echo "maven")
          PORT=$(yq eval '.service.runtime.port' "$SERVICE_CONFIG" || echo "8080")
          EXTERNAL=$(yq eval '.service.networking.external' "$SERVICE_CONFIG" || echo "false")
          NEEDS_DB=$(yq eval '.service.dependencies.database' "$SERVICE_CONFIG" || echo "false")
          NEEDS_KAFKA=$(yq eval '.service.dependencies.kafka' "$SERVICE_CONFIG" || echo "false")
          NEEDS_REDIS=$(yq eval '.service.dependencies.redis' "$SERVICE_CONFIG" || echo "false")
          
          echo "language=$LANGUAGE" >> $GITHUB_OUTPUT
          echo "port=$PORT" >> $GITHUB_OUTPUT
          echo "external=$EXTERNAL" >> $GITHUB_OUTPUT
          echo "needs_db=$NEEDS_DB" >> $GITHUB_OUTPUT
          echo "needs_kafka=$NEEDS_KAFKA" >> $GITHUB_OUTPUT
          echo "needs_redis=$NEEDS_REDIS" >> $GITHUB_OUTPUT
          
          echo "üìã Service Configuration:"
          echo "   Language: $LANGUAGE"
          echo "   Port: $PORT"
          echo "   External: $EXTERNAL"
          echo "   Dependencies: DB=$NEEDS_DB, Kafka=$NEEDS_KAFKA, Redis=$NEEDS_REDIS"
      
      - name: Setup Build Tools
        run: |
          case "${{ steps.config.outputs.language }}" in
            maven)
              echo "‚òï Setting up Java/Maven..."
              sudo apt-get update
              sudo apt-get install -y openjdk-21-jdk
              echo "JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64" >> $GITHUB_ENV
              ;;
            dotnet)
              echo "üî∑ Setting up .NET..."
              # .NET setup will be handled by setup-dotnet action
              ;;
            node)
              echo "üì¶ Setting up Node.js..."
              # Node setup will be handled by setup-node action
              ;;
          esac
      
      - name: Setup .NET
        if: steps.config.outputs.language == 'dotnet'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
      
      - name: Setup Node.js
        if: steps.config.outputs.language == 'node'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Run Tests
        if: ${{ !github.event.inputs.skip_tests }}
        working-directory: ${{ needs.discover-service.outputs.service_path }}
        run: |
          case "${{ steps.config.outputs.language }}" in
            maven)
              echo "üß™ Running Maven tests..."
              mvn -B -ntp clean test
              ;;
            dotnet)
              echo "üß™ Running .NET tests..."
              dotnet test
              ;;
            node)
              echo "üß™ Running Node.js tests..."
              npm test || yarn test || echo "‚ö†Ô∏è No test script found"
              ;;
            *)
              echo "‚ö†Ô∏è No test command for language: ${{ steps.config.outputs.language }}"
              ;;
          esac
      
      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Login to ACR
        run: az acr login --name ${{ secrets.ACR_NAME }}
      
      - name: Build and Push Image
        id: build
        run: |
          SERVICE_NAME="${{ needs.discover-service.outputs.service_name }}"
          SERVICE_PATH="${{ needs.discover-service.outputs.service_path }}"
          SERVICE_CONFIG="${{ needs.discover-service.outputs.service_config }}"
          
          # Get build context from config
          CONTEXT=$(yq eval '.service.build.context' "$SERVICE_CONFIG" 2>/dev/null || echo ".")
          DOCKERFILE=$(yq eval '.service.build.dockerfile' "$SERVICE_CONFIG" 2>/dev/null || echo "Dockerfile")
          
          # Normalize null/empty context to current dir
          if [ -z "$CONTEXT" ] || [ "$CONTEXT" = "null" ]; then
            CONTEXT="."
          fi
          
          # Normalize null/empty dockerfile to default
          if [ -z "$DOCKERFILE" ] || [ "$DOCKERFILE" = "null" ]; then
            DOCKERFILE="Dockerfile"
          fi
          
          IMAGE="${{ secrets.ACR_NAME }}.azurecr.io/${SERVICE_NAME}:latest"
          IMAGE_TAG="${{ secrets.ACR_NAME }}.azurecr.io/${SERVICE_NAME}:${{ github.sha }}"
          
          echo "üèóÔ∏è Building Docker image..."
          echo "   Context: $SERVICE_PATH/$CONTEXT"
          echo "   Dockerfile: $SERVICE_PATH/$DOCKERFILE"
          
          docker build \
            -f "$SERVICE_PATH/$DOCKERFILE" \
            -t "$IMAGE" \
            -t "$IMAGE_TAG" \
            "$SERVICE_PATH/$CONTEXT"
          
          echo " Pushing images..."
          docker push "$IMAGE"
          docker push "$IMAGE_TAG"
          
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          echo " Image built and pushed: $IMAGE"

  terraform-plan:
    name: Terraform Plan
    needs: [discover-service, build-and-test]
    runs-on: ubuntu-latest
    outputs:
      plan_output: ${{ steps.plan.outputs.stdout }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (plan)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Export ARM env (plan)
        run: |
          set -euo pipefail
          SUBS=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')
          TENANT=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          CLIENT=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
          SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
          echo "ARM_SUBSCRIPTION_ID=$SUBS" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=$TENANT" >> $GITHUB_ENV
          echo "ARM_CLIENT_ID=$CLIENT" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=$SECRET" >> $GITHUB_ENV

      - name: Validate required inputs (plan)
        run: |
          set -euo pipefail

          if [ -z "${{ secrets.AZURE_RG_NAME }}" ]; then
            echo "AZURE_RG_NAME secret is required (resource group for self-service example)."
            exit 1
          fi
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5
      
      - name: Parse Service Config
        id: config
        run: |
          SERVICE_CONFIG="${{ needs.discover-service.outputs.service_config }}"
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          PORT=$(yq eval '.service.runtime.port' "$SERVICE_CONFIG" || echo "8080")
          EXTERNAL=$(yq eval '.service.networking.external' "$SERVICE_CONFIG" || echo "false")
          CPU=$(yq eval '.service.runtime.cpu' "$SERVICE_CONFIG" || echo "0.5")
          MEMORY=$(yq eval '.service.runtime.memory' "$SERVICE_CONFIG" || echo "1.0Gi")
          MIN_REPLICAS=$(yq eval '.service.runtime.min_replicas' "$SERVICE_CONFIG" || echo "0")
          MAX_REPLICAS=$(yq eval '.service.runtime.max_replicas' "$SERVICE_CONFIG" || echo "3")
          
          echo "port=$PORT" >> $GITHUB_OUTPUT
          echo "external=$EXTERNAL" >> $GITHUB_OUTPUT
          echo "cpu=$CPU" >> $GITHUB_OUTPUT
          echo "memory=$MEMORY" >> $GITHUB_OUTPUT
          echo "min_replicas=$MIN_REPLICAS" >> $GITHUB_OUTPUT
          echo "max_replicas=$MAX_REPLICAS" >> $GITHUB_OUTPUT
      
      - name: Terraform Init
        working-directory: modules/self_service/examples
        run: terraform init -input=false
      
      - name: Terraform Plan
        id: plan
        working-directory: modules/self_service/examples
        run: |
          terraform plan -input=false \
            -var="service_key=${{ needs.discover-service.outputs.service_name }}" \
            -var="aca_subnet_id=${{ secrets.ACA_SUBNET_ID }}" \
            -var="service_port=${{ steps.config.outputs.port }}" \
            -var="external=${{ steps.config.outputs.external }}" \
            -var="image=${{ needs.build-and-test.outputs.image }}" \
            -var="cpu=${{ steps.config.outputs.cpu }}" \
            -var="memory=${{ steps.config.outputs.memory }}" \
            -var="min_replicas=${{ steps.config.outputs.min_replicas }}" \
            -var="max_replicas=${{ steps.config.outputs.max_replicas }}" \
            -var="resource_group_name=${{ secrets.AZURE_RG_NAME }}" \
            -out=tfplan | tee plan_output.txt
          
          echo "stdout<<EOF" >> $GITHUB_OUTPUT
          cat plan_output.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ needs.discover-service.outputs.service_name }}-${{ github.run_id }}
          path: modules/self_service/examples/tfplan

  terraform-apply:
    name: Terraform Apply
    needs: [discover-service, build-and-test, terraform-plan]
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.auto_approve == 'true') ||
      (github.ref == 'refs/heads/production' && github.event_name == 'push')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (apply)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Export ARM env (apply)
        run: |
          set -euo pipefail
          SUBS=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.subscriptionId')
          TENANT=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.tenantId')
          CLIENT=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientId')
          SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r '.clientSecret')
          echo "ARM_SUBSCRIPTION_ID=$SUBS" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=$TENANT" >> $GITHUB_ENV
          echo "ARM_CLIENT_ID=$CLIENT" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=$SECRET" >> $GITHUB_ENV

      - name: Validate required inputs (apply)
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.AZURE_RG_NAME }}" ]; then
            echo "AZURE_RG_NAME secret is required (resource group for self-service example)."
            exit 1
          fi
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5
      
      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-${{ needs.discover-service.outputs.service_name }}-${{ github.run_id }}
          path: modules/self_service/examples

      - name: Terraform Init (apply)
        working-directory: modules/self_service/examples
        run: terraform init -input=false

      - name: Validate plan artifact
        working-directory: modules/self_service/examples
        run: |
          set -euo pipefail
          if [ ! -f tfplan ]; then
            echo "‚ùå tfplan artifact missing. Plan step may have failed."
            exit 1
          fi
          terraform show -no-color tfplan > /tmp/tfplan.txt || {
            echo "‚ùå tfplan is invalid. Regenerate plan."
            exit 1
          }
      
      - name: Parse Service Config
        id: config
        run: |
          SERVICE_CONFIG="${{ needs.discover-service.outputs.service_config }}"
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          PORT=$(yq eval '.service.runtime.port' "$SERVICE_CONFIG" || echo "8080")
          EXTERNAL=$(yq eval '.service.networking.external' "$SERVICE_CONFIG" || echo "false")
          
          echo "port=$PORT" >> $GITHUB_OUTPUT
          echo "external=$EXTERNAL" >> $GITHUB_OUTPUT
      
      - name: Terraform Apply
        working-directory: modules/self_service/examples
        run: |
          set -euo pipefail
          
          RG_NAME="${{ secrets.AZURE_RG_NAME }}"
          
          # Construct Container Apps Environment name (matches module naming pattern)
          # Pattern: aca-env-${lower(replace(resource_group_name, "-", ""))}
          ENV_NAME="aca-env-$(echo $RG_NAME | tr '[:upper:]' '[:lower:]' | tr -d '-')"
          
          # Apply terraform plan
          if ! terraform apply -input=false -auto-approve tfplan 2>&1 | tee /tmp/apply_output.log; then
            APPLY_ERROR=$(cat /tmp/apply_output.log)
            
            # Only retry if error is related to subnet in use
            if echo "$APPLY_ERROR" | grep -q "InUseSubnetCannotBeDeleted\|subnet.*in use"; then
              echo "‚ö†Ô∏è  Apply failed due to subnet in use."
              echo "üí° Subnet is being used by Container Apps Environment. Deleting environment to release subnet..."
              
              # Delete Container Apps Environment (this is what uses the subnet)
              # Note: Container Apps themselves don't use the subnet directly, only the Environment does
              echo "üìã Deleting Container Apps Environment: $ENV_NAME"
              if az containerapp env show --name "$ENV_NAME" --resource-group "$RG_NAME" &>/dev/null; then
                echo "üóëÔ∏è  Deleting Container Apps Environment..."
                az containerapp env delete --name "$ENV_NAME" --resource-group "$RG_NAME" --yes || true
                
                # Wait for Environment to be fully deleted
                echo "‚è≥ Waiting for Container Apps Environment to be deleted..."
                MAX_WAIT=300  # 5 minutes max
                ELAPSED=0
                while [ $ELAPSED -lt $MAX_WAIT ]; do
                  if ! az containerapp env show --name "$ENV_NAME" --resource-group "$RG_NAME" &>/dev/null; then
                    echo "‚úÖ Container Apps Environment deleted"
                    break
                  fi
                  echo "   Still deleting... (${ELAPSED}s elapsed)"
                  sleep 10
                  ELAPSED=$((ELAPSED + 10))
                done
                
                if [ $ELAPSED -ge $MAX_WAIT ]; then
                  echo "‚ö†Ô∏è  Timeout waiting for Environment deletion, but continuing..."
                fi
                
                # Additional wait for service association links cleanup
                echo "‚è≥ Waiting additional 30s for Azure to clean up service association links..."
                sleep 30
                
                # Remove from Terraform state to avoid conflicts
                echo "üßπ Cleaning up Terraform state..."
                terraform state rm "module.aca_env.azurerm_container_app_environment.main" 2>/dev/null || true
                
                # Refresh state
                terraform refresh -input=false || true
              else
                echo "‚ö†Ô∏è  Container Apps Environment not found, may have been deleted already"
              fi
              
              # Retry apply with additional retries if still fails
              echo "üîÑ Retrying terraform apply..."
              MAX_RETRIES=3
              RETRY_COUNT=0
              
              while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                if terraform apply -input=false -auto-approve tfplan; then
                  echo "‚úÖ Terraform apply succeeded on retry $((RETRY_COUNT + 1))"
                  break
                fi
                
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "‚ö†Ô∏è  Apply failed, waiting 30s before retry $((RETRY_COUNT + 1))/$MAX_RETRIES..."
                  sleep 30
                fi
              done
              
              if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
                echo "‚ùå Terraform apply failed after $MAX_RETRIES retries"
                echo "üí° Subnet may still be in use. Manual intervention may be required."
                exit 1
              fi
            else
              echo "‚ùå Terraform apply failed with different error:"
              echo "$APPLY_ERROR"
              exit 1
            fi
          fi
          
          echo "‚úÖ Terraform apply completed successfully"
      
      - name: Get Service URL
        id: outputs
        working-directory: modules/self_service/examples
        run: |
          SERVICE_FQDN=$(terraform output -raw service_fqdn 2>/dev/null || echo "")
          SERVICE_RG=$(terraform output -raw service_resource_group 2>/dev/null || echo "")
          SERVICE_ACR=$(terraform output -raw service_acr 2>/dev/null || echo "")
          
          echo "service_fqdn=$SERVICE_FQDN" >> $GITHUB_OUTPUT
          echo "service_rg=$SERVICE_RG" >> $GITHUB_OUTPUT
          echo "service_acr=$SERVICE_ACR" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Service deployed: ${{ needs.discover-service.outputs.service_name }}"
          echo "üì¶ ACR: $SERVICE_ACR"
          echo "üìÅ Resource Group: $SERVICE_RG"
          if [ -n "$SERVICE_FQDN" ]; then
            echo "üîó Service URL: https://$SERVICE_FQDN"
          else
            echo "‚ö†Ô∏è  Service is internal (not externally accessible)"
          fi

